// Generated by CoffeeScript 1.6.3
/*!
@author Branko Vukelic <branko@brankovukelic.com>
@license MIT
*/

var _this = this;

if (typeof define !== 'function' || !define.amd) {
  this.require = function(dep) {
    return (function() {
      switch (dep) {
        case 'jquery':
          return _this.jQuery;
        case 'underscore':
          return _this._;
        case './base':
          return _this.ribcage.models.baseModel;
        default:
          return null;
      }
    })() || (function() {
      throw new Error("Unmet dependency " + dep);
    })();
  };
  this.define = function(factory) {
    var mixins, models, module, _base, _base1;
    models = (_base = (_this.ribcage || (_this.ribcage = {}))).models || (_base.models = {});
    mixins = (_base1 = _this.ribcage).modelMixins || (_base1.modelMixins = {});
    module = models.soapModel = factory(_this.require);
    models.SoapModel = module.Model;
    return mixins.SoapModel = module.mixin;
  };
}

define(function(require) {
  var $, SoapModel, baseModel, soapModelMixin, _;
  $ = require('jquery');
  _ = require('underscore');
  baseModel = require('./base');
  require('jquery.soap');
  require('jquery.xml2json');
  soapModelMixin = {
    baseUrl: 'http://example.com',
    namespace: 'http://example.com',
    debug: false,
    appendMethod: false,
    soap12: false,
    soapCreateMethod: 'Create',
    soapReadMethod: 'Read',
    soapUpdateMethod: 'Update',
    soapDeleteMethod: 'Delete',
    getSoapCreateMethod: function() {
      return this.soapCreateMethod;
    },
    getSoapReadMethod: function() {
      return this.soapReadMethod;
    },
    getSoapUpdateMethod: function() {
      return this.soapUpdateMethod;
    },
    getSoapDeleteMethod: function() {
      return this.soapDeleteMethod;
    },
    soapCreateTemplate: null,
    soapReadTemplate: null,
    soapUpdateTemplate: null,
    soapDeleteTemplate: null,
    soapCreate: function(model) {
      if (model == null) {
        model = null;
      }
      return {
        method: this.getSoapCreateMethod(),
        params: this.soapCreateTemplate((model || this).toJSON())
      };
    },
    soapRead: function(model) {
      if (model == null) {
        model = null;
      }
      return {
        method: this.getSoapReadMethod(),
        params: this.soapReadTemplate((model || this).toJSON())
      };
    },
    soapUpdate: function(model) {
      if (model == null) {
        model = null;
      }
      return {
        method: this.getSoapUpdateMethod(),
        params: this.soapUpdateTemplate((model || this).toJSON())
      };
    },
    soapDelete: function(model) {
      if (model == null) {
        model = null;
      }
      return {
        method: this.getSoapDeleteMethod(),
        params: this.soapDeleteTemplate((model || this).toJSON())
      };
    },
    getUrl: function(method, action) {
      return this.baseUrl;
    },
    getSoapActionName: function(method, soapMethod) {
      return "" + this.namespace + soapMethod;
    },
    sync: function(method, model, options) {
      var capMethod, fn, params;
      if (options == null) {
        options = {};
      }
      capMethod = "" + (method[0].toUpperCase()) + (method.slice(1));
      options.crudMethod = capMethod;
      fn = this["soap" + capMethod];
      params = fn.call(this, model);
      return $.soap(_.extend(params, options, {
        enableLogging: this.debug,
        url: this.getUrl(method, params.method),
        appendMethodToURL: this.appendMethod,
        namespaceURL: this.namespace,
        SOAPAction: this.getSoapActionName(method, params.method),
        soap12: this.soap12
      }));
    },
    convertCreateResponse: function(json) {
      throw new Error('convertCreateResponse method is not implemented');
    },
    convertReadResponse: function(json) {
      throw new Error('convertReadResponse method is not implemented');
    },
    convertUpdateResponse: function(json) {
      throw new Error('convertUpdateResponse method is not implemented');
    },
    convertDeleteResponse: function(json) {
      throw new Error('convertDeleteResponse method is not implemented');
    },
    convertResponse: function(json, options) {
      return this["convert" + options.crudMethod + "Response"](json);
    },
    parse: function(response, options) {
      return this.convertResponse(response.toJSON().Body, options);
    }
  };
  SoapModel = baseModel.Model.extend(soapModelMixin);
  return {
    mixin: soapModelMixin,
    Model: SoapModel
  };
});
