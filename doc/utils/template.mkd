# <a name="ribcage-template">Ribcage Template</a>

The code is based on Underscore template with many modifications to add new
features.

The template syntax is similar to Moustache, but it doesn't try to adhere to
any published specification.

This module depends on DaHelpers

### <a name="templateerror">`TemplateError`</a>

This exception is thrown when code fails within the compiled template. The
template will thow this exception and print out the original uncompiled source
of the template along with the actual error that was thrown.

The error which was thrown inside the template is stored in the `originalError`
property.

The uncompiled template source is stored in the `source` property.

### <a name="compileerror">`CompileError`</a>

This exception is thrown when the template cannot be compiled due to syntax
error caused by malformed JavaScript generated by the template source.

The original error which caused failure will be stored in `originalError`
property.

The compiled (and malformed) JavaScript source of the template is stored in the
`source` property.

The uncompiled version of the template which caused this error is stored in
`template` property.

   - [`TemplateError`](#templateerror)
   - [`CompileError`](#compileerror)
   - [`#escaped`](#escaped)
   - [`#literal`](#literal)
   - [`#code`](#code)
   - [`#partial`](#partial)
   - [`#comment`](#comment)
   - [`#partials`](#partials)
   - [`registerPartial(name, template)`](#registerpartial-name-template)
   - [`#makeLocal`](#makelocal)
   - [`#extraArguments`](#extraarguments)
   - [`#bind`](#bind)
   - [`#render(template, [data, settings])`](#render-template-data-settings)
   - [`template(template, [data])`](#template-template-data)


### <a name="escaped">`#escaped`</a>

Regexp for matching the escaped insertion token.

Default matches `{{ foo }}`.

This token outputs the expression it contains as HTML-escaped string.

### <a name="literal">`#literal`</a>

Regexp for matching the literal insertion token.

Default matches `{{= foo }}`.

This token outputs the expression it contains as literal string which may or
may not contain HTML markup.

### <a name="code">`#code`</a>

Regexp that matches code evaluation token.

Default matches `{% foo %}`.

This token is treated as literal JavaScript. Note that you can use the full
range of JavaScript including any variables defined in the global scope.

For example, it's possible to do

    {% articles.forEach(function (article) { %}
      <h2>{{ article.title }}</h2>
      <div class="body">{{= article.body }}</div>
    {% }); %}


You should generally insert trailing semi-colons wherever applicable.

### <a name="partial">`#partial`</a>

Regexp that matches template partial token.

Default matches `{:partialName args:}` or `{:partialName:}`

Registered partials can be inserted into the template by using this token.

For example:

    {% articles.forEach(function(article) { %}
    {: article {article: article} :}
    {% }); %}


Note that the template's context is completely overridden for the chosen
partial by the argument passed into this token. If you wish to relay the
context of the current template verbatim, simply omit the argument:

    {: articles :}


### <a name="comment">`#comment`</a>

Regexp that matches template comments token.

Default matches `{# comment #}`

This token is fairly useless under normal circumstances. It inserts a plain
JavaScript comment into the compiled template's code.

It can be used to leave comments that won't appear in the output HTML or to
provide some helpful clues when debugging compiled template source.

### <a name="partials">`#partials`</a>

Property that holds template partials.

### <a name="registerpartial-name-template">`registerPartial(name, template)`</a>

Registers a partial template giving it a name. The partial template is compiled
if `template` argument is a string. If you pass a function instead, it will
simply be assigned the name and otherwise left intact.

All partial templates will accept the same arguments as the template they are
used in, except the actual context data which may be overridden in the partial
token.

### <a name="makelocal">`#makeLocal`</a>

Whether to make context object's properties local variables by using the `with`
statement within the compiled template source. Default is `true`.

### <a name="extraarguments">`#extraArguments`</a>

Key-value pairs of named arguments that will be passed to the template.

For example:

   extraArguments: {jQuery: $}


The above code will make a `jQuery` name available inside the template which
points to the value of `$` variable. This is different from the partials in
that you can pass arbitrary JavaScript objects such modules with helper
functions.

Furthermore, if overridden for the whole module, this property will make all
arguments available to all templates.

### <a name="bind">`#bind`</a>

Object to which the compiled template function will be bound. By defualt, this
is the DaHelpers module. `this` within the template will be set to this value.

### <a name="render-template-data-settings">`#render(template, [data, settings])`</a>

Renders the template down to either a function or a string. It renders to
function if no data is supplied, otherwise renders to string.

The settings object can contain any of the properties of this module and the
settings properties will override the ones defined on the module.

### <a name="template-template-data">`template(template, [data])`</a>

Alias for `#render()`.