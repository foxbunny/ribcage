# # Ribcage Template
#
# The code is based on Underscore template with many modifications to add new
# features.
#
# The template syntax is similar to Moustache, but it doesn't try to adhere to
# any published specification.
#

define = ((root) ->
  if typeof root.define is 'function' and root.define.amd
    root.define
  else
    require = (dep) ->
      (() ->
        switch dep
          when 'dahelpers' then root.dahelpers
          else null
      )() or throw new Error "Unmet dependency #{dep}"
    (factory) =>
      module = factory require
      root.ribcage.utils.template = module
) this

define (require) ->

  # This module depends on DaHelpers
  #
  dh = require 'dahelpers'

  # ### `TemplateError`
  #
  # This exception is thrown when code fails within the compiled template. The
  # template will thow this exception and print out the original uncompiled
  # source of the template along with the actual error that was thrown.
  #
  # The error which was thrown inside the template is stored in the
  # `originalError` property.
  #
  # The uncompiled template source is stored in the `source` property.
  #
  class TemplateError extends Error
    constructor: (@message, @originalError, @source) ->
      @name = 'TemplateError'

  # ### `CompileError`
  #
  # This exception is thrown when the template cannot be compiled due to syntax
  # error caused by malformed JavaScript generated by the template source.
  #
  # The original error which caused failure will be stored in `originalError`
  # property.
  #
  # The compiled (and malformed) JavaScript source of the template is stored in
  # the `source` property.
  #
  # The uncompiled version of the template which caused this error is stored in
  # `template` property.
  #
  class CompileError extends Error
    constructor: (@message, @originalError, @source, @template) ->
      @name = 'CompileError'

  # ::TOC::
  #

  # ### `#syntaxSet`
  #
  # Syntax set to use for rendering. Default is 'underscore'.
  #
  syntaxSet: 'underscore'

  # ### `#syntaxSets`
  #
  # Predefined token regexps that provide syntax like other template engines.
  #
  # You can use the `#syntaxSet` property to choose the set you want to use.
  #
  syntaxSets:
    # #### Underscore set
    #
    # Use `'underscore'` in `#syntaxSet`.
    #
    # These are Underscore-compatible tokens. Since Ribcage template engine
    # supports more features than Underscore counterpart, there are additional
    # tokens that do not appear in the original Underscore templates.
    underscore:
      # ##### Escaped
      #
      #     <%- expr %>
      #
      # Escapes the output of the expression.
      #
      escaped: /<%-([\s\S]+?)%>/

      # ##### Literal
      #
      #     <%= expr %>
      #
      # Outputs the expression unaltered including any HTML tags if present.
      #
      literal: /<%=([\s\S]+?)%>/

      # ##### Code
      #
      #     <% code %>
      #
      # Outputs literal JavaScript code (and blocks thereof).
      #
      code: /<%([^-=][\s\S]*?)%>/

      # ##### Partial template
      #
      #     <: name :>
      #     <: name context :>
      #
      # Includes a registered partial template with optional context object
      # which overrides the current template's context.
      #
      partial: /<: *([a-zA-Z0-9_$]+(?: (?:[$a-zA-Z0-9_$]+|\{[\s\S]+?\}))?) *:>/

      # ##### Comment
      #
      #     <# comment #>
      #
      # Inserts a JavaScript comment into the compiled source.
      #
      comment: /<#([\s\S]+?)#>/

    # #### Ribcage set
    #
    # Use `'ribcage'` in `#syntaxSet`.
    #
    # Ribcage tokens are very similar to template languages like Django and
    # Moustache, but don't really conform to any spec.
    #
    ribcage:
      # ##### Escaped
      #
      #     {{ foo }}
      #
      # This token outputs the expression it contains as HTML-escaped string.
      #
      escaped: /\{\{([^=][\s\S]*?)\}\}/

      # ##### Literal
      #
      #     {{= foo }}
      #
      # This token outputs the expression it contains as literal string which may
      # or may not contain HTML markup.
      #
      literal: /\{{=([\s\S]+?)\}\}/

      # ##### Code
      #
      #     {% foo %}
      #
      # This token is treated as literal JavaScript. Note that you can use the full
      # range of JavaScript including any variables defined in the global scope.
      #
      # For example, it's possible to do
      #
      #     {% articles.forEach(function (article) { %}
      #       <h2>{{ article.title }}</h2>
      #       <div class="body">{{= article.body }}</div>
      #     {% }); %}
      #
      # You should generally insert trailing semi-colons wherever applicable.
      #
      code: /\{%([\s\S]+?)%\}/

      # ##### Partial
      #
      #     {: name :}
      #     {: name context :}
      #
      # Registered partials can be inserted into the template by using this token.
      #
      # For example:
      #
      #     {% articles.forEach(function(article) { %}
      #     {: article {article: article} :}
      #     {% }); %}
      #
      # Note that the template's context is completely overridden for the chosen
      # partial by the argument passed into this token. If you wish to relay the
      # context of the current template verbatim, simply omit the argument:
      #
      #     {: articles :}
      #
      partial: /\{: *([a-zA-Z0-9_$]+(?: (?:[$a-zA-Z0-9_$]+|\{[\s\S]+?\}))?) *:\}/

      # ##### Comment
      #
      #     {# comment #}
      #
      # This token is fairly useless under normal circumstances. It inserts a plain
      # JavaScript comment into the compiled template's code.
      #
      # It can be used to leave comments that won't appear in the output HTML or
      # to provide some helpful clues when debugging compiled template source.
      #
      comment: /\{#([\s\S]+?)#\}/

  # ### `#partials`
  #
  # Property that holds template partials.
  #
  partials: {}

  # ### `registerPartial(name, template)`
  #
  # Registers a partial template giving it a name. The partial template is
  # compiled if `template` argument is a string. If you pass a function
  # instead, it will simply be assigned the name and otherwise left intact.
  #
  # All partial templates will accept the same arguments as the template they
  # are used in, except the actual context data which may be overridden in the
  # partial token.
  #
  registerPartial: (name, template) ->
    if typeof template is 'function'
      @partials[name] = template
    else
      @partials[name] = @render template

  # ### `#makeLocal`
  #
  # Whether to make context object's properties local variables by using the
  # `with` statement within the compiled template source. Default is `true`.
  #
  makeLocal: true

  # ### `#extraArguments`
  #
  # Key-value pairs of named arguments that will be passed to the template.
  #
  # For example:
  #
  #    extraArguments: {jQuery: $}
  #
  # The above code will make a `jQuery` name available inside the template
  # which points to the value of `$` variable. This is different from the
  # partials in that you can pass arbitrary JavaScript objects such modules
  # with helper functions.
  #
  # Furthermore, if overridden for the whole module, this property will make
  # all arguments available to all templates.
  #
  extraArguments: {}

  htmlEscape: (html) ->
    html.
      replace(/&/g, '&amp;').
      replace(/</g, '&lt;').
      replace(/>/g, '&gt;').
      replace(/"/g, '&quot;').
      replace(/'/g, '&#39;')

  stringEscape:
    "'": "'"
    '\\': '\\'
    '\r': 'r'
    '\n': 'n'
    '\t': 't'
    '\u2028': 'u2028'
    '\u2029': 'u2029'

  stringEscapeRe: /\\|'|\r|\n|\t|\u2028|\u2029/g

  # ### `#bind`
  #
  # Object to which the compiled template function will be bound. By defualt,
  # this is the DaHelpers module. `this` within the template will be set to
  # this value.
  #
  bind: dh

  # ### `#render(template, [data, settings])`
  #
  # Renders the template down to either a function or a string. It renders to
  # function if no data is supplied, otherwise renders to string.
  #
  # The settings object can contain any of the properties of this module and
  # the settings properties will override the ones defined on the module.
  #
  render: (template, data=null, settings={}) ->
    settings = dh.mixin {}, settings,
      escaped: @syntaxSets[@syntaxSet].escaped
      literal: @syntaxSets[@syntaxSet].literal
      code: @syntaxSets[@syntaxSet].code
      partial: @syntaxSets[@syntaxSet].partial
      comment: @syntaxSets[@syntaxSet].comment
      partials: @syntaxSets[@syntaxSet].partials
      makeLocal: @makeLocal
      htmlEscape: @htmlEsacpe
      extraArguments: @extraArguments
      bind: @bind

    htmlEscape = @htmlEscape

    tokensRe = new RegExp [
      settings.escaped.source
      settings.literal.source
      settings.code.source
      settings.partial.source
      settings.comment.source
    ].join('|') + '|$', 'g'

    stringEscapeRe = @stringEscapeRe
    stringEscape = @stringEscape

    source = "    __s += '"
    index = 0
    template.replace tokensRe, (m, escaped, literal, code, partial, comment, offset) ->
      source += template.
        slice(index, offset).
        replace stringEscapeRe, (m) -> '\\' + stringEscape[m]

      if escaped
        source += "' +\n    ((__v=('' + " + escaped + ")) == null ? '' : __e(__v)) +\n'"
      if literal
        source += "' +\n    ((__v=('' + " + literal + ")) == null ? '' : __v) +\n'"
      if code
        source += "';\n    " + code + "\n__s += '"
      if partial
        [name, args...] = partial.trim().split(' ')
        args = args.join ' '
        source += "' +\n    ((__p['" + name.trim() + "'] || __d).apply('" + name + "', "
        if args
          source += "[" + args + "].concat([].slice.call(arguments, 1))"
        else
          source += "arguments"
        source += ")) +\n    '"
      if comment
        source += "';\n/*" + comment + "*/\n    __s += '"

      index = offset + m.length
      m

    s = "var __s = '';\n"
    s += "var __v;\n"
    s += "var __d = function () { return ''; };\n"
    s += "var self = this;\n"
    s += "var print = function () { __s += [].join.call(arguments, ''); };\n"
    s += 'try {\n'
    s += '  with (ctx) {\n' if settings.makeLocal
    s += source
    s += "';\n"
    s += "    return __s;\n"
    s += '  }\n' if settings.makeLocal
    s += '} catch (e) {\n'
    s += "    var __templateError__ = new TemplateError(\n"
    s += "      '' + e + '\\nin template:\\n\\n' + __source__, e, __source__);\n"
    s += '    throw __templateError__;\n'
    s += '}\n'

    args = ['ctx', '__e', '__p', '__source__', 'TemplateError']
    args = args.concat Object.keys settings.extraArguments
    args = args.concat s

    try
      fn = Function.apply null, args
    catch e
      throw new CompileError 'template could not be compiled', e, s, template

    render = (ctx) ->
      extras = settings.extraArguments
      ctxArgs = [data, htmlEscape, settings.partials, template, TemplateError]
      ctxArgs = ctxArgs.concat Object.keys(extras).map (k) -> extras[k]
      fn.apply settings.bind, ctxArgs

    if data?
      render data
    else
      (data) -> render data

  # ### `template(template, [data])`
  #
  # Alias for `#render()`.
  #
  template: () ->
    @render arguments...
