// Generated by CoffeeScript 1.6.3
/*!
@author Branko Vukelic <branko@brankovukelic.com>
@license MIT
*/

var _this = this;

if (typeof define !== 'function' || !define.amd) {
  this.require = function(dep) {
    return (function() {
      switch (dep) {
        case 'underscore':
          return _this._;
        case './methods':
          return _this.ribcage.validators.methods;
        default:
          return null;
      }
    })() || (function() {
      throw new Error("Unmet dependency " + dep);
    })();
  };
  this.define = function(factory) {
    var _base;
    (_base = (_this.ribcage || (_this.ribcage = {}))).validators || (_base.validators = {});
    return _this.ribcage.validators.mixins = factory(_this.require);
  };
}

define(function(require) {
  var methods, modelValidatingMixin, validatingMixin, _;
  _ = require('underscore');
  methods = require('./methods');
  validatingMixin = {
    /*
    #validators
    
    An object containig name-method pairs of validators. You can add your
    custom validators here. It defaults to validators found in
    `ribcage/validators/methods` module.
    
    You can use Underscore.js's `#extend()` method to add yours:
    
      validators: _.extend(methods, {
        myValidator: function(s) { .... }
      })
    
    Each custom validator method must take a single string value, and return
    an array containing the cleaned value (value converted to appropraite
    format usable by your application) and and status. The status is a boolean
    value which should be `true` if the value is valid, or `false` if it's not.
    */

    validators: methods,
    /*
    #rules
    
    This object describes the validation rules. Each rule maps an attribute
    name to an object that contains validation mappings. For example:
    
        rules: {
          name: {
            required: 'Name is required'
          },
          email: {
            required: 'Email is required',
            email: 'Email must be a valid email'
          }
        }
    
    A special key `__all` is used to validate the entire form data.
    
        rules: {
          password: {
            required: 'Password cannot be blank'
          },
          passwordConfirm: {
            required: 'Please type in your password again'
          },
          __all: {
            customValidator: 'Passwords do not match'
          }
        }
    
    Key in the validation mapping represents the name of the validator method.
    Valid methods are:
    
     + required
     + email
     + numeric
     + integer
    
    Note that none of the default validator methods work with entire data sets,
    so be sure to add your own validators if you want to validate sets of data.
    */

    rules: {},
    /*
    #applyValidators(name, val)
    
    Applies validators to a single value. The errors are either `null` if value
    is valid, or an array of messages for invalid value.
    
    @param name {String} Attribute name
    @param val {String} Value to validate
    @return {Array} [errors, value]
    */

    applyValidators: function(name, val) {
      var errors, method, msg, valid, _ref, _ref1;
      errors = null;
      _ref = this.rules[name];
      for (method in _ref) {
        msg = _ref[method];
        if (!method in this.validators) {
          throw new Error("" + method + " is not a validator method");
        }
        _ref1 = this.validators[method](val), val = _ref1[0], valid = _ref1[1];
        if (!valid) {
          errors || (errors = []);
          errors.push(msg);
        }
      }
      return [errors, val];
    },
    /*
    #cleanFields(dada)
    
    Validates fields using given rules in the `#rules` object. The return value
    maps attribute names to an Array of error messages.
    
    @param data {Object} Object containing the data to be cleaned
    @return {Array} [errorObject, cleanedData]
    */

    cleanFields: function(data) {
      var attribute, cleaned, errors, messages, val, _ref;
      cleaned = {};
      errors = null;
      if (_.isEmpty(this.rules)) {
        return [errors, data];
      }
      for (attribute in data) {
        val = data[attribute];
        if (!attribute in this.rules) {
          continue;
        }
        _ref = this.applyValidators(attribute, val), messages = _ref[0], val = _ref[1];
        if (messages === null) {
          cleaned[attribute] = val;
        } else {
          errors || (errors = {});
          errors[attribute] = messages;
        }
      }
      return [errors, cleaned];
    },
    /*
    #clean(data)
    
    Cleans fields and entire data set.
    
    @param data {Object} Object containing the data to be cleaned
    @return {Array} [errorObject, cleanedData]
    */

    clean: function(data) {
      var cleaned, errors, _ref;
      _ref = this.cleanFields(data), errors = _ref[0], cleaned = _ref[1];
      if (errors || !'__all' in this.rules) {
        return [errors, cleaned];
      }
      return this.applyValidators('__all', data);
    }
  };
  modelValidatingMixin = _.extend(validatingMixin, {
    validate: function(attributes) {
      var data, errors, _ref;
      _ref = this.clean(attributes), errors = _ref[0], data = _ref[1];
      if (!_.isEmpty(errors)) {
        return errors;
      } else {
        this.attributes = data;
        return null;
      }
    }
  });
  return {
    validatingMixin: validatingMixin,
    modelValidatingMixin: modelValidatingMixin
  };
});
