// Generated by LiveScript 1.2.0
/**
 * @author Branko Vukelic <branko@brankovukelic.com>
 * @license MIT
 */
var define;
define = function(root){
  var require;
  if (typeof root.define === 'function' && root.define.amd) {
    return root.define;
  } else {
    require = function(dep){
      return function(){
        switch (dep) {
        case './base':
          return root.ribcage.models.baseModel;
        case '../utils/localstorage':
          return root.ribcage.utils.LocalStorage;
        case '../utils/localstore':
          return root.ribcage.utils.LocalStore;
        default:
          return null;
        }
      }() || (function(){
        throw new Error("Unmet dependency " + dep);
      }());
    };
    return function(factory){
      var module, r;
      module = factory(require);
      r = root.ribcage || (root.ribcage = {});
      (r.models || (r.models = {})).localStorageModel = module;
      r.models.LocalStorageModel = module.Model;
      return (r.modelMixins || (r.modelMixins = {})).LocalStorageModel = module.mixin;
    };
  }
}(this);
define(function(require){
  var Model, LocalStore, storage, LocalStorageModelMixin, LocalStorageModel;
  Model = require('./base').Model;
  rqeuire()({
    LocalStorage: '../utils/localstorage'
  });
  LocalStore = require('../utils/localstore');
  storage = new LocalStorage();
  return {
    mixin: LocalStorageModelMixin = {
      store: null,
      storageKey: null,
      persistent: true,
      initialize: function(){
        return this.store = new LocalStore(this.storageKey, storage, this.idProperty);
      },
      sync: function(method, model, options){
        var methodMap, dataMethods, alterMethods, url;
        options == null && (options = {});
        methodMap = {
          read: 'GET',
          create: 'POST',
          update: 'PUT',
          patch: 'PATCH',
          'delete': 'DELETE'
        };
        if (options.forceCreate && method === 'update') {
          method = 'create';
          options.noFail = true;
        }
        dataMethods = ['create', 'update', 'patch'];
        alterMethods = dataMethods.concat(['delete']);
        if (!this.persistent && in$(method, alterMethods)) {
          options.success(model.attributes);
        }
        if (in$(method, dataMethods)) {
          options.data = model ? model.attributes : null;
        }
        options.success == null && (options.success = function(){});
        options.error == null && (options.error = function(){});
        url = options.url = model.id || null;
        options.type = methodMap[method];
        return this.store.query(url, options);
      },
      destroy: function(){
        if (!this.persistent) {
          return;
        }
        return this.sync('delete', this);
      },
      makePersistent: function(){
        this.persistent = true;
        return this.save();
      },
      unpersist: function(){
        this.persistent = false;
        return this.store.destroyStore();
      }
    },
    Model: LocalStorageModel = (function(superclass){
      var prototype = extend$((import$(LocalStorageModel, superclass).displayName = 'LocalStorageModel', LocalStorageModel), superclass).prototype, constructor = LocalStorageModel;
      importAll$(prototype, arguments[1]);
      function LocalStorageModel(){
        LocalStorageModel.superclass.apply(this, arguments);
      }
      return LocalStorageModel;
    }(Model, LocalStorageModelMixin))
  };
});
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}