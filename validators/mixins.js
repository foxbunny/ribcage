// Generated by CoffeeScript 1.6.3
/*!
@author Branko Vukelic <branko@brankovukelic.com>
@license MIT
*/

var _this = this;

if (typeof define !== 'function' || !define.amd) {
  this.require = function(dep) {
    return (function() {
      switch (dep) {
        case 'underscore':
          return _this._;
        case './methods':
          return _this.ribcage.validators.methods;
        default:
          return null;
      }
    })() || (function() {
      throw new Error("Unmet dependency " + dep);
    })();
  };
  this.define = function(factory) {
    return _this.ribcage.validators.mixins = factory(_this.require);
  };
}

define(function(require) {
  var methods, modelValidatingMixin, validatingMixin, _;
  _ = require('underscore');
  methods = require('./methods');
  validatingMixin = {
    validators: methods,
    rules: {},
    applyValidators: function(name, val) {
      var errors, method, msg, valid, _ref, _ref1;
      errors = null;
      _ref = this.rules[name];
      for (method in _ref) {
        msg = _ref[method];
        if (!method in this.validators) {
          throw new Error("" + method + " is not a validator method");
        }
        _ref1 = this.validators[method](val), val = _ref1[0], valid = _ref1[1];
        if (!valid) {
          errors || (errors = []);
          errors.push(msg);
        }
      }
      return [errors, val];
    },
    cleanFields: function(data) {
      var attribute, cleaned, errors, messages, val, _ref;
      cleaned = {};
      errors = null;
      if (_.isEmpty(this.rules)) {
        return [errors, data];
      }
      for (attribute in data) {
        val = data[attribute];
        if (!attribute in this.rules) {
          continue;
        }
        _ref = this.applyValidators(attribute, val), messages = _ref[0], val = _ref[1];
        if (messages === null) {
          cleaned[attribute] = val;
        } else {
          errors || (errors = {});
          errors[attribute] = messages;
        }
      }
      return [errors, cleaned];
    },
    clean: function(data) {
      var cleaned, errors, _ref;
      _ref = this.cleanFields(data), errors = _ref[0], cleaned = _ref[1];
      if (errors || !'__all' in this.rules) {
        return [errors, cleaned];
      }
      return this.applyValidators('__all', data);
    }
  };
  modelValidatingMixin = _.extend(validatingMixin, {
    validate: function(attributes) {
      var data, errors, _ref;
      _ref = this.clean(attributes), errors = _ref[0], data = _ref[1];
      if (!_.isEmpty(errors)) {
        return errors;
      } else {
        this.attributes = data;
        return null;
      }
    }
  });
  return {
    validatingMixin: validatingMixin,
    modelValidatingMixin: modelValidatingMixin
  };
});
